# Simplified Klondike Solitaire implementation for AlphaZero-General
# Author: AutoGenerated

import numpy as np
from Game import Game


class KlondikeGame(Game):
    """Simplified Klondike Solitaire (draw one card) implementation."""

    # board constants
    STOCK = 0
    WASTE = 1
    FOUNDATION = 2
    TABLEAU_1 = 3
    TABLEAU_2 = 4
    TABLEAU_3 = 5

    MAX_STACK = 20
    ACTION_SIZE = 14

    def __init__(self):
        super().__init__()

    def _empty_board(self):
        return np.zeros((6, self.MAX_STACK + 1), dtype=int)

    def getInitBoard(self):
        """Return the initial game board."""
        np.random.seed(42)
        # create 13 cards with random colors (1 for red, -1 for black)
        deck = []
        for value in range(1, 14):
            color = np.random.choice([1, -1])
            deck.append(color * value)
        np.random.shuffle(deck)

        board = self._empty_board()
        # deal 1,2,3 cards to tableau columns
        counts = [1, 2, 3]
        index = 0
        for col, c in enumerate(counts, start=self.TABLEAU_1):
            board[col, 0] = c
            board[col, 1:c + 1] = deck[index:index + c]
            index += c
        # remaining cards to stock
        remaining = deck[index:]
        board[self.STOCK, 0] = len(remaining)
        if remaining:
            board[self.STOCK, 1:len(remaining) + 1] = remaining
        return board

    def getBoardSize(self):
        """Return board dimensions."""
        return (6, self.MAX_STACK + 1)

    def getActionSize(self):
        """Return number of possible actions."""
        return self.ACTION_SIZE

    def _top_card(self, board, pile):
        count = int(board[pile, 0])
        if count == 0:
            return None
        return int(board[pile, count])

    def _pop(self, board, pile):
        count = int(board[pile, 0])
        card = int(board[pile, count])
        board[pile, count] = 0
        board[pile, 0] = count - 1
        return card

    def _push(self, board, pile, card):
        count = int(board[pile, 0]) + 1
        board[pile, count] = card
        board[pile, 0] = count

    def _opposite_color(self, card_a, card_b):
        return (card_a > 0) != (card_b > 0)

    def getNextState(self, board, player, action):
        """Apply action and return new (board, player)."""
        b = np.copy(board)
        if action == 0:  # draw from stock
            if b[self.STOCK, 0] > 0:
                card = self._pop(b, self.STOCK)
                self._push(b, self.WASTE, card)
        elif action == 1:  # waste -> foundation
            card = self._top_card(b, self.WASTE)
            if card is not None:
                needed = int(b[self.FOUNDATION, 0]) + 1
                if abs(card) == needed:
                    self._pop(b, self.WASTE)
                    self._push(b, self.FOUNDATION, card)
        elif 2 <= action <= 4:  # waste -> tableau
            dest = self.TABLEAU_1 + (action - 2)
            card = self._top_card(b, self.WASTE)
            if card is not None:
                dest_top = self._top_card(b, dest)
                if dest_top is None:
                    if abs(card) == 13:
                        self._pop(b, self.WASTE)
                        self._push(b, dest, card)
                else:
                    if abs(card) == abs(dest_top) - 1 and self._opposite_color(card, dest_top):
                        self._pop(b, self.WASTE)
                        self._push(b, dest, card)
        elif 5 <= action <= 7:  # tableau -> foundation
            src = self.TABLEAU_1 + (action - 5)
            card = self._top_card(b, src)
            if card is not None:
                needed = int(b[self.FOUNDATION, 0]) + 1
                if abs(card) == needed:
                    self._pop(b, src)
                    self._push(b, self.FOUNDATION, card)
        elif 8 <= action <= 13:  # tableau -> tableau
            mapping = {
                8: (self.TABLEAU_1, self.TABLEAU_2),
                9: (self.TABLEAU_1, self.TABLEAU_3),
                10: (self.TABLEAU_2, self.TABLEAU_1),
                11: (self.TABLEAU_2, self.TABLEAU_3),
                12: (self.TABLEAU_3, self.TABLEAU_1),
                13: (self.TABLEAU_3, self.TABLEAU_2),
            }
            src, dest = mapping[action]
            card = self._top_card(b, src)
            if card is not None:
                dest_top = self._top_card(b, dest)
                if dest_top is None:
                    if abs(card) == 13:
                        self._pop(b, src)
                        self._push(b, dest, card)
                else:
                    if abs(card) == abs(dest_top) - 1 and self._opposite_color(card, dest_top):
                        self._pop(b, src)
                        self._push(b, dest, card)
        return b, player

    def getValidMoves(self, board, player):
        """Return binary vector of valid moves."""
        valids = [0] * self.ACTION_SIZE
        # draw
        if board[self.STOCK, 0] > 0:
            valids[0] = 1
        # waste -> foundation
        card = self._top_card(board, self.WASTE)
        if card is not None:
            needed = int(board[self.FOUNDATION, 0]) + 1
            if abs(card) == needed:
                valids[1] = 1
            # waste -> tableau
            for i in range(3):
                dest = self.TABLEAU_1 + i
                dest_top = self._top_card(board, dest)
                if dest_top is None:
                    if abs(card) == 13:
                        valids[2 + i] = 1
                else:
                    if abs(card) == abs(dest_top) - 1 and self._opposite_color(card, dest_top):
                        valids[2 + i] = 1
        # tableau -> foundation and tableau -> tableau
        for i in range(3):
            src = self.TABLEAU_1 + i
            card = self._top_card(board, src)
            if card is None:
                continue
            needed = int(board[self.FOUNDATION, 0]) + 1
            if abs(card) == needed:
                valids[5 + i] = 1
            for j in range(3):
                if i == j:
                    continue
                dest = self.TABLEAU_1 + j
                dest_top = self._top_card(board, dest)
                idx = 8 + i * 2 + (j - (j > i))
                # compute mapping index manually
                if dest == self.TABLEAU_1 and src == self.TABLEAU_2:
                    idx = 10
                if dest == self.TABLEAU_3 and src == self.TABLEAU_2:
                    idx = 11
                if dest == self.TABLEAU_1 and src == self.TABLEAU_3:
                    idx = 12
                if dest == self.TABLEAU_2 and src == self.TABLEAU_3:
                    idx = 13
                if dest_top is None:
                    if abs(card) == 13:
                        valids[idx] = 1
                else:
                    if abs(card) == abs(dest_top) - 1 and self._opposite_color(card, dest_top):
                        valids[idx] = 1
        return np.array(valids)

    def getGameEnded(self, board, player):
        """Check if game is ended."""
        if board[self.FOUNDATION, 0] == 13:
            return 1
        if any(self.getValidMoves(board, player)):
            return 0
        return -1

    def getCanonicalForm(self, board, player):
        """Return board (single player game)."""
        return np.copy(board)

    def getSymmetries(self, board, pi):
        """No symmetries for solitaire."""
        assert len(pi) == self.ACTION_SIZE
        return [(np.copy(board), np.copy(pi))]

    def stringRepresentation(self, board):
        """Convert board to string."""
        return board.tostring()

